#labels Phase-Implementation
=Sections=

  # [#Conversation_Redirects Conversation Redirects]
  # [#Memory_Management Memory Management]
  # [#Exception_Mapping Exception Mapping]

----

==Conversation Redirects==

If the standard Struts2 result types "redirect" and "redirectAction" are used, then the action conversations are not propagated along with the redirect.  If you wish to allow redirects of conversations, then the following approach should be used:


In the struts.xml, either extend struts-conversation-default package:

{{{
<package name="your-package" extends="struts-conversation-default">
}}}


Or, declare the result types in your package:

{{{
<package name="your-package" extends="struts-default">
   <result-types>
      <result-type name="conversationRedirectAction" class="com.google.code.rees.scope.struts2.ConversationActionRedirectResult"/>
      <result-type name="conversationRedirect" class="com.google.code.rees.scope.struts2.ConversationRedirectResult"/>
   </result-types>
}}}


Then, in your result mapping set the result type as either "conversationRedirect" or "conversationRedirectAction", and the conversations will propagate over the redirection.

----
==Memory Management==

Conversations have a default idle-time timeout of 8 hours in order to keep old conversations from taking up system resources.  Conversations are, by default, monitored once every 5 minutes to scan for cleanup of the stale conversations.  As well, there is a default maximum of 20 instances of each conversation per session to prevent users from unnecessarily overloading the system by creating countless conversations (so, in the above example, there could be up to 20 "base" conversations, 20 "registration" conversations, etc.).  The size of the timeout monitoring thread-pool can be configured also (the default is 20).  Each of these settings can be changed in the struts.xml by configuring constants:


{{{
<!-- monitoring frequency in milliseconds -->
<constant name="conversation.monitoring.frequency" value="300000"/>

<!-- idle conversation timeout in milliseconds -->
<constant name="conversation.idle.timeout" value="28800000"/>

<!-- max instances of a conversation -->
<constant name="conversation.max.instances" value="20"/>

<!-- number of timeout monitoring threads -->
<constant name="conversation.monitoring.thread.pool.size" value="20"/>
}}}

If you wish to have different timeouts for different conversations, the BeginConversation annotation can be used to specify a different timeout period (this feature only available since version _1.6.1_:

{{{
//This conversation will only last 10 seconds!
@BeginConversation(maxIdleTimeMillis=10000L)
public String begin() {
   return "hurry";
}
}}}

It is important to note the an HttpSessionListener is used to cleanup each session's conversation resources when the session ends.  This listener will startup automatically for Servlet API 3.0+.  For earlier Servlet APIs, the listener should be configured in the web.xml:

{{{
<!-- only needed for apps not using Servlet API 3.0 or greater -->
<listener>
   <listener-class>com.google.code.rees.scope.conversation.context.ConversationCleanupListener</listener-class>
</listener>
}}}

----

==Exception Mapping==

_since 1.6.1_

Inevitably, users will sometimes submit a request that contains an ID for a conversation that has already expired or that has been explicitly ended on another tab that they have open.  When this happens, the framework will throw a ConversationException.  This exception can be used to map to a result of your choosing to gracefully (or not!) handle the situation:

{{{
        <global-results>
            <result name="ConversationException">/GlobalConversationException.jsp</result>
        </global-results>

        <global-exception-mappings>
            <exception-mapping exception="com.google.code.rees.scope.conversation.ConversationException" result="ConversationException"/>
        </global-exception-mappings>
}}}

More on exception mapping in Struts2:  http://struts.apache.org/2.x/docs/exception-configuration.html